import numpy as np
import sympy as sp

# 행렬 입력
def input_matrix():
    n = int(input("정방행렬의 크기 n을 입력하세요: "))
    matrix = []
    print(f"{n}×{n} 행렬의 각 행을 입력하세요 (공백으로 숫자 구분):")
    for i in range(n):
        row = list(map(float, input(f"행 {i+1}: ").split()))
        if len(row) != n:
            raise ValueError("입력한 행의 원소 개수가 틀렸습니다")
        matrix.append(row)
    return np.array(matrix)

# 행렬식 이용
def inverse_by_determinant(matrix):
    det = np.linalg.det(matrix)
    if abs(det) < 1e-10:
        raise ValueError("이 행렬은 역행렬이 존재하지 않습니다")
    inv = np.linalg.inv(matrix)
    return inv

# 가우스-조던 소거법 이용
def inverse_by_gauss_jordan(matrix):
    n = len(matrix)
    aug = np.hstack((matrix.astype(float), np.identity(n)))
    
    for i in range(n):
        if abs(aug[i][i]) < 1e-10:
            for j in range(i+1, n):
                if abs(aug[j][i]) > 1e-10:
                    aug[[i, j]] = aug[[j, i]]
                    break
            else:
                raise ValueError("이 행렬은 역행렬이 존재하지 않습니다")
        
        pivot = aug[i][i]
        aug[i] = aug[i] / pivot
        
        for j in range(n):
            if i != j:
                factor = aug[j][i]
                aug[j] = aug[j] - factor * aug[i]
    
    inv = aug[:, n:]
    return inv

# 케일리 해밀턴 정리 이용
def inv_by_cayley_hamilton(A):
    A = sp.Matrix(A)

    detA = A.det()
    if detA == 0:
        raise ValueError("이 행렬은 역행렬이 존재하지 않습니다")

    lam = sp.Symbol('λ')
    poly = A.charpoly(lam)
    coeffs = poly.all_coeffs()
    n = A.shape[0]

    a0 = coeffs[-1]
    expr = sp.zeros(n)
    for i in range(1, n):
        expr += coeffs[i] * (A ** (n - 1 - i))
    expr += A ** (n - 1)

    inv_ch = -expr / a0
    inv_ch = sp.simplify(inv_ch)

    def clean_number(x):
        if isinstance(x, sp.Float):
            if abs(x - round(x)) < 1e-10:
                return int(round(x))
        elif x.is_Rational:
            if x.q == 1:
                return int(x.p)
        return x

    inv_ch = inv_ch.applyfunc(clean_number)

    return inv_ch




# 결과 출력 & 비교
def main():
    try:
        A = input_matrix()

        inv_det = inverse_by_determinant(A)
        print("\n행렬식을 이용한 역행렬")
        print(inv_det)

        inv_gj = inverse_by_gauss_jordan(A)
        print("\n가우스-조던 소거법을 이용한 역행렬")
        print(inv_gj)

        if np.allclose(inv_det, inv_gj):
            print("\n 두 방법의 결과가 같습니다")
        else:
            print("\n 두 방법의 결과가 다릅니다")

        inv3 = inv_by_cayley_hamilton(A)
        print("\n<참고: 케일리–해밀턴 정리 방식을 이용한 역행렬>")
        sp.pprint(sp.simplify(inv3))

    except Exception as e:
        print("\n오류:", e)


if __name__ == "__main__":
    main()
